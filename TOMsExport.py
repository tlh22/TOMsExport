# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TOMsExport
                                 A QGIS plugin
 Export of TOMs geometry data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-11-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by TH
        email                : th"mhtc.co.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox

from qgis.PyQt.QtCore import (
    QObject,
    QTimer,
    pyqtSignal,
    QSettings, QTranslator, qVersion, QCoreApplication
)

from qgis.core import (
    QgsExpressionContextUtils,
    QgsExpression,
    QgsFeatureRequest,
    # QgsMapLayerRegistry,
    QgsMessageLog, QgsFeature, QgsGeometry,
    QgsTransaction, QgsTransactionGroup,
    QgsProject,
    QgsVectorFileWriter,
    QgsApplication,
    QgsVectorLayer,
    QgsFields, QgsDataSourceUri, QgsWkbTypes
)

from qgis.gui import QgsFileWidget

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .TOMsExport_dialog import TOMsExportDialog
import os.path
import time
import datetime

from .generateGeometryUtils import generateGeometryUtils

# TODO: Deal with paths. Ideally want to have this plugin using the same folders as TOMs

from .restrictionTypeUtilsClass import RestrictionTypeUtilsMixin

class setupTableNames(QObject):

    TOMsLayersNotFound = pyqtSignal()
    """ signal will be emitted with there is a problem with opening TOMs - typically a layer missing """

    def __init__(self, iface):
        QObject.__init__(self)
        self.iface = iface

        QgsMessageLog.logMessage("In setupTableNames.init ...", tag="TOMs panel")
        #self.proposalsManager = proposalsManager

        #RestrictionsLayers = QgsMapLayerRegistry.instance().mapLayersByName("RestrictionLayers")[0]
        """self.TOMsLayerList = [["Bays", ["Length", "RestrictionTypeID", "NrBays", "TimePeriodID", "PayTypeID", "MaxStayID", "NoReturnID",
                                        "GeometryID", "BaysWordingID", "RoadName", "USRN", "OpenDate",
                                        "CPZ", "ParkingTariffArea"], 'AND "GeomShapeID" < 20', 'Line'],
                              ["Bays", ["Length", "RestrictionTypeID", "NrBays", "TimePeriodID", "PayTypeID", "MaxStayID", "NoReturnID",
                                        "GeometryID", "BaysWordingID", "RoadName", "USRN", "OpenDate",
                                        "CPZ", "ParkingTariffArea"], 'AND "GeomShapeID" > 20', 'Polygon'],
                              ["Lines", ["Length", "RestrictionTypeID", "NoWaitingTimeID", "NoLoadingTimeID", "GeometryID",
                                         "RoadName", "USRN", "OpenDate", "CPZ", "ParkingTariffArea"], 'AND "GeomShapeID" > 0', 'Line'],
                         #"Signs",
                            ["RestrictionPolygons", ["RestrictionTypeID", "OpenDate", "USRN", "RoadName",
                                                     "GeometryID", "NoWaitingTimeID", "NoLoadingTimeID",
                                                     "TimePeriodID", "AreaPermitCode", "CPZ"], '', 'Polygon'],
                            ["CPZs", ["WaitingTimeID", "CPZ", "OpenDate", "GeometryID"], '', 'Polygon'],
                            ["ParkingTariffAreas", ["id", "Name", "NoReturnTimeID", "MaxStayID", "TimePeriodID", "OpenDate"], '', 'Polygon']
                         ]"""
        self.TOMsLayerList = [
            #"Signs",
                            ["RestrictionPolygons", ["RestrictionTypeID", "OpenDate", "USRN", "RoadName",
                                                     "GeometryID", "NoWaitingTimeID", "NoLoadingTimeID",
                                                     "TimePeriodID", "AreaPermitCode", "CPZ"], '', 'Polygon'],
                            ["CPZs", ["WaitingTimeID", "CPZ", "OpenDate", "GeometryID"], '', 'Polygon'],
                            ["ParkingTariffAreas", ["id", "Name", "NoReturnTimeID", "MaxStayID", "TimePeriodID", "OpenDate"], '', 'Polygon']
                         ]
        self.TOMsLayerDict = {}

    def getLayers(self):

        QgsMessageLog.logMessage("In setupTableNames.getLayers ...", tag="TOMs panel")
        found = True

        # Check for project being open
        project = QgsProject.instance()

        if len(project.fileName()) == 0:
            QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Project not yet open"))
            found = False

        else:

            for layer in self.TOMsLayerList:
                if QgsProject.instance().mapLayersByName(layer[0]):
                    self.TOMsLayerDict[layer[0]] = QgsProject.instance().mapLayersByName(layer[0])[0]
                else:
                    QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Table " + layer + " is not present"))
                    found = False
                    break

            if QgsProject.instance().mapLayersByName("Bays"):
                self.BAYS = QgsProject.instance().mapLayersByName("Bays")[0]
            else:
                QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Table Bays is not present"))
                found = False

            if QgsProject.instance().mapLayersByName("Lines"):
                self.LINES = QgsProject.instance().mapLayersByName("Lines")[0]
            else:
                QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Table Lines is not present"))
                found = False

            if QgsProject.instance().mapLayersByName("Signs"):
                self.SIGNS = QgsProject.instance().mapLayersByName("Signs")[0]
            else:
                QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Table Signs is not present"))
                found = False

            if QgsProject.instance().mapLayersByName("RestrictionPolygons"):
                self.RESTRICTION_POLYGONS = QgsProject.instance().mapLayersByName("RestrictionPolygons")[0]
            else:
                QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Table RestrictionPolygons is not present"))
                found = False

            if QgsProject.instance().mapLayersByName("CPZs"):
                self.CPZs = QgsProject.instance().mapLayersByName("CPZs")[0]
            else:
                QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Table CPZs is not present"))
                found = False

            if QgsProject.instance().mapLayersByName("ParkingTariffAreas"):
                self.PARKING_TARIFF_AREAS = QgsProject.instance().mapLayersByName("ParkingTariffAreas")[0]
            else:
                QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Table ParkingTariffAreas is not present"))
                found = False

        # TODO: need to deal with any errors arising ...

        if found == False:
            self.TOMsLayersNotFound.emit()

        return self.TOMsLayerList


class TOMsExport:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'TOMsExport_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&TOMsExport')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        self.closeTOMs = False

        # Set up log file and collect any relevant messages
        logFilePath = os.environ.get('QGIS_LOGFILE_PATH')

        if logFilePath:

            QgsMessageLog.logMessage("LogFilePath: " + str(logFilePath), tag="TOMs panel")

            logfile = 'qgis_' + datetime.date.today().strftime("%Y%m%d") + '.log'
            self.filename = os.path.join(logFilePath, logfile)
            QgsMessageLog.logMessage("Sorting out log file" + self.filename, tag="TOMs panel")
            QgsApplication.instance().messageLog().messageReceived.connect(self.write_log_message)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('TOMsExport', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/TOMsExport/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'TOMs Export'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&TOMsExport'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False

            self.tableNames = setupTableNames(self.iface)
            self.tableNames.TOMsLayersNotFound.connect(self.setCloseTOMsFlag)
            self.TOMsLayerList = self.tableNames.getLayers()

            if self.closeTOMs:
                QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Unable to start TOMs ..."))
                return

            self.dlg = TOMsExportDialog()

            fileNameWidget = self.dlg.findChild(QgsFileWidget, "fileNameWidget")
            fileNameWidget.setStorageMode(QgsFileWidget.SaveFile)
            fileNameWidget.setFilter("Geopackage (*.gpkg);;JPEG (*.jpg *.jpeg);;TIFF (*.tif)")
            fileNameWidget.setSelectedFilter("Geopackage (*.gpkg)")

            # show the dialog
            self.dlg.show()
            # Run the dialog event loop
            result = self.dlg.exec_()
            # See if OK was pressed
            if result:

                # Open geopackage

                canvas = self.iface.mapCanvas()
                layer = canvas.currentLayer()

                fileName = fileNameWidget.filePath()
                # QMessageBox.information(self.iface.mainWindow(), "Message", ("Filename is ..." + str(fileName)))
                QgsMessageLog.logMessage("Filename is ..." + str(fileName), tag="TOMs panel")

                """options = QgsVectorFileWriter.SaveVectorOptions()
                options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
                # to get rid of spaces in the layer name
                options.layerName = "_".join(layer.name().split(' '))

                writer = QgsVectorFileWriter.writeAsVectorFormat(layer, "V:/test_layer/test_gpkg", options)"""

                # Get list of all the layers that are required within the Geopackage

                # Could check whether or not file exists. If, firstPass is False
                firstPass = True
                firstBaysPass = True

                for layer in self.TOMsLayerList:
                    if QgsProject.instance().mapLayersByName(layer[0]):

                        QgsMessageLog.logMessage("Considering " + str(layer[0]), tag="TOMs panel")
                        currLayer = QgsProject.instance().mapLayersByName(layer[0])[0]

                        # Create a new layer with geometry column and type

                        reqFields = layer[1]
                        condition = layer[2]
                        geomType = layer[3]

                        # newLayer = QgsVectorLayer(newURI.uri(False), newLayerName)


                        # Now add the layer to the geopackage

                        options = QgsVectorFileWriter.SaveVectorOptions()

                        ext = 'export'
                        if currLayer.name() == "Bays":
                            if firstBaysPass:
                                firstBaysPass = False
                                ext='exportLines'
                                options.overrideGeometryType = QgsWkbTypes.LineString
                                #geomType = 'Line'
                                # ext='exportPolygons'
                                # options.overrideGeometryType = QgsWkbTypes.Polygon
                            else:
                                ext='exportPolygons'
                                options.overrideGeometryType = QgsWkbTypes.Polygon
                                #geomType = 'Polygon'
                        else:
                            options.overrideGeometryType = currLayer.wkbType()
                            """if currLayer.name() == "Lines":
                                geomType = 'Line'
                            else:
                                geomType = 'Polygon'"""

                        newLayerName = '{currLayerName}_{ext}'.format(currLayerName=currLayer.name(), ext=ext)

                        #newDetails = "'{type}'?={crs}".format(type=geomType, crs=currLayer.crs())
                        #newLayer = QgsVectorLayer(fileName, newLayerName)
                        newLayer = QgsVectorLayer("{type}?={crs}".format(type='Polygon', #QgsWkbTypes.geometryDisplayString(int(options.overrideGeometryType)),
                                                                     crs=currLayer.crs()), newLayerName, "memory")
                        #newLayer.setCrs(currLayer.crs())  # This stops the "Select CRS" popup

                        """writerObj = QgsVectorFileWriter(vectorFileName=fileName,
                                                        fileEncoding='UTF-8',
                                                        fields=self.setFieldsForTOMsExportLayer(currLayer, reqFields),
                                                        srs=currLayer.crs(),
                                                        geometryType=options.overrideGeometryType,
                                                        driverName=options.driverName,
                                                        datasourceOptions=[newURI.uri()])

                        self.writer = writerObj.writeAsVectorFormat(newLayer, fileName, options)
                        if self.writer:
                            QgsMessageLog.logMessage("Error: " + newLayer.name() + " " + str(self.writer), tag="TOMs panel")
                            print(currLayer.name(), self.writer)

                        newLayerA = self.iface.addVectorLayer(fileName+ "|layername=" + newLayerName, newLayerName, "ogr")"""

                        # self.setTOMsExportLayerFields(currLayer, newLayer, reqFields)
                        newLayer.startEditing()
                        newFields = self.setFieldsForTOMsExportLayer(currLayer, reqFields)
                        newLayer.dataProvider().addAttributes(newFields)
                        newLayer.commitChanges()

                        # Get geometry and list of fields
                        # Create a new feature from the current feature
                        # newLayer.startEditing()
                        self.addTOMsRestrictionsToLayer(currLayer, newLayer, reqFields, condition)
                        # newLayerA = self.iface.addVectorLayer(fileName+ "|layername=" + newLayerName, newLayerName, "ogr")

                        # newLayer.commitChanges()
                        # newURI = currLayer.dataProvider().uri()
                        newURI = newLayer.dataProvider().uri()
                        # newURI = QgsDataSourceUri()
                        newURI.setDatabase(fileName)
                        newURI.setDataSource('', newLayerName, "SHAPE")
                        newURI.setSrid = currLayer.crs()
                        newURI.setTable = newLayerName
                        newURI.setKeyColumn = currLayer.primaryKeyAttributes()[0]

                        if firstPass:
                            firstPass = False
                        else:
                            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer

                        # options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer

                        options.layerName = newLayerName
                        options.driverName = "GPKG"
                        options.datasourceOptions = [newURI.uri()]
                        options.destCRS = currLayer.crs()

                        self.writer = QgsVectorFileWriter.writeAsVectorFormat(newLayer, fileName, options)
                        if self.writer:
                            QgsMessageLog.logMessage("Error: " + newLayer.name() + " " + str(self.writer), tag="TOMs panel")
                            print(currLayer.name(), self.writer)

                        newLayerA = self.iface.addVectorLayer(fileName + "|layername=" + newLayerName, newLayerName,
                                                              "ogr")

                        # QgsProject.instance().addMapLayer(newLayerA)
                        # del self.writer
                        # del newLayer
                        # del newLayer

                    else:
                        QMessageBox.information(self.iface.mainWindow(), "ERROR", ("Table " + layer + " is not present"))
                        found = False
                        break

    def setCloseTOMsFlag(self):
        self.closeTOMs = True

    def addNewgeometryField(self):
        pass

    def write_log_message(self, message, tag, level):
        # filename = os.path.join('C:\Users\Tim\Documents\MHTC', 'qgis.log')
        with open(self.filename, 'a') as logfile:
            logfile.write('{dateDetails}:: {message}\n'.format(dateDetails= time.strftime("%Y%m%d:%H%M%S"), message=message))

    def setTOMsExportLayerFields(self, currLayer, newLayer, reqFields):

        currFields = currLayer.fields()

        """ Loop through all the fields in currLayer and add as appropriate"""
        newLayer.startEditing()
        for field in currFields:
            if field.name() in reqFields:
                status = newLayer.addAttribute(field)
                if status == False:
                    QgsMessageLog.logMessage("Error adding " + field.name(), tag="TOMs panel")

        newLayer.commitChanges()

        return

    def setFieldsForTOMsExportLayer(self, currLayer, reqFields):

        currFields = currLayer.fields()
        newFields = QgsFields()

        """ Loop through all the fields in currLayer and add as appropriate"""
        #newLayer.startEditing()
        for field in currFields:
            if field.name() in reqFields:
                status = newFields.append(field)
                # status = newLayer.addAttribute(field)
                if status == False:
                    QgsMessageLog.logMessage("Error adding " + field.name(), tag="TOMs panel")

                    #newLayer.commitChanges()

        return newFields

    def addTOMsRestrictionsToLayer(self, currLayer, newLayer, reqFields, condition):

        currFields = currLayer.fields()
        # reqFields = newLayer.fields()
        reqFieldsList = newLayer.fields().toList()

        exp = '"OpenDate" IS NOT NULL AND "CloseDate" IS NULL {condition}'.format(condition=condition)
        exp = QgsExpression(exp)
        QgsMessageLog.logMessage("In addTOMsRestrictionsToLayer - " + currLayer.name() + ". Expression " + str(exp), tag="TOMs panel")

        request = QgsFeatureRequest(exp)

        newLayer.startEditing()
        for restriction in currLayer.getFeatures(request):

            QgsMessageLog.logMessage("In AddRestrictionsToLayer - " + currLayer.name() + ". Considering " + str(restriction.attribute(currLayer.primaryKeyAttributes()[0])), tag="TOMs panel")
            newFeature = QgsFeature(newLayer.fields())
            for field in currFields:

                if field.name() in reqFields:
                    QgsMessageLog.logMessage("Adding " + field.name() + ":" + str(restriction.attribute(field.name())), tag="TOMs panel")
                    newFeature.setAttribute(field.name(), restriction.attribute(field.name()))

            if condition:
                newGeom = generateGeometryUtils.getRestrictionGeometry(restriction)
                newFeature.setGeometry(newGeom)
            else:
                newFeature.setGeometry(restriction.geometry())

            newLayer.addFeature(newFeature)

            del newFeature
            # self.writer.addFeature(newFeature)
            """ TODO: Check for errors """
        newLayer.commitChanges()
        del exp
        del request

        return